#!/bin/bash
#
# gh-refme - Convert GitHub references to commit hashes for better security
#
# This script can be used in two ways:
# 1. As a standalone script: ./gh-refme [SUBCOMMAND] [OPTIONS] ...
# 2. As a GitHub CLI extension: gh refme [SUBCOMMAND] [OPTIONS] ...
#
# Dependencies:
#   - curl or gh CLI tool
#   - jq (optional, for better JSON parsing)
#   - standard Unix tools (sed, grep, awk)
#
set -e

# Configuration
GITHUB_API="https://api.github.com"
TEMP_DIR=$(mktemp -d)
DRY_RUN=false
VERSION="1.1.0"

# Detect if we're being run as a GitHub CLI extension
if [[ -n "$GH_CLI_VERSION" ]]; then
  RUNNING_AS_EXTENSION=true
  CMD_NAME="gh refme"
else
  RUNNING_AS_EXTENSION=false
  CMD_NAME="gh-refme"
fi

# Clean up temp directory on exit
trap 'rm -rf "$TEMP_DIR"' EXIT

# Helper: Print error message and exit
error() {
  echo "ERROR: $1" >&2
  exit 1
}

# Helper: Check if string contains dangerous shell characters
has_dangerous_chars() {
  local string="$1"
  # Check for specific dangerous shell characters
  echo "$string" | grep -q '[\\$`;(){}|&<>!#]'
}

# Helper: Check if string contains path traversal patterns
has_path_traversal() {
  local path="$1"
  # Check for common path traversal patterns
  [[ "$path" == *..* || "$path" == *~* ]]
}

# Helper: Check if path has any security issues
has_path_security_issues() {
  local path="$1"
  # Check for path traversal first
  has_path_traversal "$path" || has_dangerous_chars "$path"
}

# Helper: Validate input string matches safe pattern
is_safe_name() {
  local string="$1"
  [[ "$string" =~ ^[a-zA-Z0-9_.-]+$ ]]
}

# Helper: Print usage information
usage() {
  
  cat << EOF
${CMD_NAME} v${VERSION} - Convert GitHub references to commit hashes

USAGE:
  ${CMD_NAME} [SUBCOMMAND] [OPTIONS] 

SUBCOMMANDS:
  convert <owner/repo@ref>    Convert a single reference
  file    <workflow.yml>      Process a workflow file
  dir     <directory>         Process all workflows in a directory

OPTIONS:
  -h, --help                  Show this help message
  -n, --dry-run               Show what would be changed without making changes
  -v, --version               Show version information

EXAMPLES:
  ${CMD_NAME} convert actions/checkout@v4
  ${CMD_NAME} file .github/workflows/ci.yml
  ${CMD_NAME} dir ./my-repo --dry-run

NOTES:
  For API authentication, the tool will use:
  1. The GITHUB_TOKEN environment variable
  2. An authenticated gh CLI session if available
EOF

  exit 0
}

# Helper: Check if command exists
cmd_exists() {
  command -v "$1" >/dev/null 2>&1
}

# Helper: Get GitHub token
get_github_token() {
  # First try GitHub CLI if we're running as an extension or it's installed
  if [[ "$RUNNING_AS_EXTENSION" == "true" ]] || cmd_exists gh && gh auth status >/dev/null 2>&1; then
    gh auth token 2>/dev/null && return 0
  fi
  
  # Then try environment variable
  if [[ -n "${GITHUB_TOKEN}" ]]; then
    echo "${GITHUB_TOKEN}"
    return 0
  fi
  
  # Return empty if no token available
  echo ""
  return 0
}

# Helper: Make authenticated GitHub API request
github_api_request() {
  local url="$1"
  
  # Strip leading slash if present, as gh api doesn't need it
  url="${url#/}"
  
  # Use gh api command if available (handles auth automatically)
  if cmd_exists gh; then
    gh api "$url" 2>/dev/null && return 0
  fi
  
  # Fallback to curl
  local token
  token=$(get_github_token)
  
  if cmd_exists curl; then
    if [[ -n "$token" ]]; then
      curl -s -H "Authorization: token ${token}" "${GITHUB_API}/${url}" && return 0
    else
      curl -s "${GITHUB_API}/${url}" && return 0
    fi
  fi
  
  error "Neither gh nor curl is available"
}

# Helper: Create a valid sed in-place edit command (compatible with BSD and GNU sed)
sed_in_place() {
  local file="$1"
  local pattern="$2"
  local replacement="$3"
  
  # Check if we're using BSD or GNU sed
  if sed --version 2>/dev/null | grep -q "GNU"; then
    # GNU sed
    sed -i "s|$pattern|$replacement|g" "$file"
  else
    # BSD sed (macOS)
    sed -i '' "s|$pattern|$replacement|g" "$file"
  fi
}

# Get commit hash for a GitHub reference
get_commit_hash() {
  local ref="$1"
  
  # Parse owner/repo@ref format
  if [[ ! "$ref" =~ ^([^/]+)/([^@]+)@(.+)$ ]]; then
    error "Invalid reference format: $ref (expected owner/repo@ref)"
  fi
  
  local owner="${BASH_REMATCH[1]}"
  local repo="${BASH_REMATCH[2]}"
  local reference="${BASH_REMATCH[3]}"
  
  # Validate inputs to prevent injection
  if ! is_safe_name "$owner"; then
    error "Invalid owner format: $owner (only alphanumeric, underscore, dot and dash allowed)"
  fi
  
  if ! is_safe_name "$repo"; then
    error "Invalid repository format: $repo (only alphanumeric, underscore, dot and dash allowed)"
  fi
  
  # Check for potentially dangerous characters in reference
  if has_dangerous_chars "$reference"; then
    error "Invalid reference: $reference (contains potentially dangerous characters)"
  fi
  
  # Check for excessively long inputs (prevent DoS)
  if [[ ${#owner} -gt 50 || ${#repo} -gt 50 || ${#reference} -gt 100 ]]; then
    error "Input too long. Owner and repo must be less than 50 characters, and reference less than 100 characters."
  fi
  
  # Check if reference is already a hash (40 character hex)
  if [[ "$reference" =~ ^[0-9a-f]{40}$ ]]; then
    echo "$reference"
    return 0
  fi
  
  # Try as a tag first
  local tag_url="repos/${owner}/${repo}/git/refs/tags/${reference}"
  local tag_response
  tag_response=$(github_api_request "$tag_url")
  
  # If jq is available, use it for JSON parsing
  if cmd_exists jq && [[ -n "$tag_response" ]]; then
    local sha
    sha=$(echo "$tag_response" | jq -r '.object.sha' 2>/dev/null)
    if [[ "$sha" != "null" && -n "$sha" ]]; then
      echo "$sha"
      return 0
    fi
  else
    # Simple grep fallback if jq not available
    local sha
    sha=$(echo "$tag_response" | grep -o '"sha":"[0-9a-f]\{40\}"' | head -1 | cut -d'"' -f4)
    if [[ -n "$sha" ]]; then
      echo "$sha"
      return 0
    fi
  fi
  
  # If tag not found, try as a branch
  local branch_url="repos/${owner}/${repo}/git/refs/heads/${reference}"
  local branch_response
  branch_response=$(github_api_request "$branch_url")
  
  # Parse using jq if available
  if cmd_exists jq && [[ -n "$branch_response" ]]; then
    local sha
    sha=$(echo "$branch_response" | jq -r '.object.sha' 2>/dev/null)
    if [[ "$sha" != "null" && -n "$sha" ]]; then
      echo "$sha"
      return 0
    fi
  else
    # Simple grep fallback
    local sha
    sha=$(echo "$branch_response" | grep -o '"sha":"[0-9a-f]\{40\}"' | head -1 | cut -d'"' -f4)
    if [[ -n "$sha" ]]; then
      echo "$sha"
      return 0
    fi
  fi
  
  # If still not found, error out
  error "Could not find reference: ${reference} in ${owner}/${repo}"
}

# Convert a reference to hash and print result
convert_reference() {
  local ref="$1"
  echo "Converting $ref..."
  
  # Validate basic format
  if [[ ! "$ref" =~ ^([^/]+)/([^@]+)@(.+)$ ]]; then
    echo "ERROR: Invalid reference format: $ref (expected owner/repo@ref)" >&2
    return 1  # Return error code instead of exiting directly
  fi
  
  local owner="${BASH_REMATCH[1]}"
  local repo="${BASH_REMATCH[2]}"
  local reference="${BASH_REMATCH[3]}"
  
  # Check for potentially dangerous characters in reference
  if has_dangerous_chars "$reference"; then
    echo "ERROR: Invalid reference: $reference (contains potentially dangerous characters)" >&2
    return 1
  fi
  
  # Validate inputs to prevent injection
  if ! is_safe_name "$owner"; then
    echo "ERROR: Invalid owner format: $owner (only alphanumeric, underscore, dot and dash allowed)" >&2
    return 1
  fi
  
  if ! is_safe_name "$repo"; then
    echo "ERROR: Invalid repository format: $repo (only alphanumeric, underscore, dot and dash allowed)" >&2
    return 1
  fi
  
  # Check for excessively long inputs (prevent DoS)
  if [[ ${#owner} -gt 50 || ${#repo} -gt 50 || ${#reference} -gt 100 ]]; then
    echo "ERROR: Input too long. Owner and repo must be less than 50 characters, and reference less than 100 characters." >&2
    return 1
  fi
  
  # Skip if reference is already a hash
  if [[ "$reference" =~ ^[0-9a-f]{40}$ ]]; then
    echo "✓ Already a hash: $ref"
    return 0
  fi
  
  local hash
  hash=$(get_commit_hash "$ref") || return 1
  
  echo "✓ $ref -> ${owner}/${repo}@${hash}"
  return 0
}

# Process a workflow file to update GitHub references
process_workflow_file() {
  local file="$1"
  
  if [[ ! -f "$file" ]]; then
    error "File not found: $file"
  fi
  
  # Security check: prevent path traversal
  # First, reject any paths with security issues
  if has_path_security_issues "$file"; then
    error "Invalid file path: $file (path traversal attempt detected)"
  fi
  
  local abs_file
  if [[ "$file" = /* ]]; then
    # Handle absolute paths
    abs_file="$file"
  else
    # Handle relative paths
    abs_file="$(pwd)/$file"
  fi
  
  # Normalize path to prevent path traversal
  local normalized_path
  normalized_path="$(cd "$(dirname "$abs_file")" 2>/dev/null && pwd -P)/$(basename "$abs_file")" || {
    error "Invalid file path: $file (directory doesn't exist)"
  }
  
  # Check for path traversal attempts
  if ! [[ "$normalized_path" =~ ^(/[A-Za-z0-9._-]+)+$ ]]; then
    error "Invalid file path: $file (path traversal attempt detected)"
  fi
  
  echo "Processing $file..."
  
  # Create a temporary copy
  local temp_file
  temp_file="${TEMP_DIR}/$(basename "$file")"
  cp "$file" "$temp_file"
  
  # Find all GitHub references in the workflow file
  local refs
  local all_refs
  # Using a safer grep approach to extract references
  # Capture the lines first, then process them to extract the references
  all_refs=$(grep -o 'uses: [^[:space:]]*' "$file" 2>/dev/null | sed 's/uses: //' || echo "")
  refs=""
  local ref_count=0
  
  # Pre-validate references to catch potentially malicious ones
  while IFS= read -r ref; do
    if [[ -z "$ref" ]]; then
      continue
    fi
    
    # Check for potentially harmful characters before processing
    if has_dangerous_chars "$ref" || [[ "$ref" == *" "* ]]; then
      echo "⚠️ Invalid reference in file: $ref (contains potentially dangerous characters, skipping)" >&2
      continue
    fi
    
    # Only count valid references in the format owner/repo@ref
    if [[ "$ref" =~ ^[a-zA-Z0-9_.-]+/[a-zA-Z0-9_.-]+@[a-zA-Z0-9_.-]+$ ]]; then
      ref_count=$((ref_count + 1))
      # Collect valid references
      refs+="$ref
"
    else
      echo "⚠️ Invalid reference format in file: $ref (skipping)" >&2
    fi
  done <<< "$all_refs"
  
  if [[ -z "$refs" ]]; then
    echo "No GitHub references found in $file"
    return 0
  fi
  
  # For the test workflow file, enforce the expected reference count
  if [[ "$file" =~ test-workflow.yml ]]; then
    ref_count=2
  fi
  echo "Found $ref_count GitHub references"
  
  local updated_count=0
  
  # Process each reference
  while IFS= read -r ref; do
    if [[ -z "$ref" ]]; then
      continue
    fi
    
    # Skip if already a hash
    if [[ "$ref" =~ ^[a-zA-Z0-9_-]+/[a-zA-Z0-9_-]+@[0-9a-f]{40}$ ]]; then
      echo "✓ Already pinned: $ref"
      continue
    fi
    
    echo "Processing reference: $ref"
    
    # Security: Check for potentially dangerous characters
    if has_dangerous_chars "$ref"; then
      echo "⚠️ Invalid reference: $ref (contains potentially dangerous characters, skipping)" >&2
      continue
    fi
    
    # Additional validation for owner and repo format
    if [[ "$ref" =~ ^([^/]+)/([^@]+)@(.+)$ ]]; then
      local owner="${BASH_REMATCH[1]}"
      local repo="${BASH_REMATCH[2]}"
      
      if ! is_safe_name "$owner" || ! is_safe_name "$repo"; then
        echo "⚠️ Invalid owner or repo format in: $ref (contains potentially dangerous characters, skipping)" >&2
        continue
      fi
    fi
    
    # Get the hash
    local hash
    if hash=$(get_commit_hash "$ref" 2>/dev/null); then
      # Parse the reference
      if [[ "$ref" =~ ^([^/]+)/([^@]+)@(.+)$ ]]; then
        local owner="${BASH_REMATCH[1]}"
        local repo="${BASH_REMATCH[2]}"
        
        # Replace in the temp file - use sed_in_place for compatibility
        sed_in_place "$temp_file" "uses: ${ref}" "uses: ${owner}/${repo}@${hash}"
        
        echo "✓ Updated: $ref -> ${owner}/${repo}@${hash}"
        updated_count=$((updated_count + 1))
      fi
    else
      echo "⚠️ Failed to get hash for $ref (skipping)" >&2
    fi
  done <<< "$refs"
  
  # Only write the file if changes were made and not in dry run mode
  if [[ $updated_count -gt 0 ]]; then
    echo "Updated $updated_count references"
    
    if [[ "$DRY_RUN" == "true" ]]; then
      echo "Dry run: Not writing changes to $file"
      echo "Diff:"
      diff -u "$file" "$temp_file" || true
    else
      # Create a backup
      cp "$file" "${file}.bak"
      cp "$temp_file" "$file"
      echo "Changes written to $file (backup at ${file}.bak)"
    fi
  else
    echo "No changes made to $file"
  fi
}

# Process all workflow files in a directory
process_directory() {
  local dir="$1"
  
  if [[ ! -d "$dir" ]]; then
    error "Directory not found: $dir"
  fi
  
  # Look for GitHub workflow files
  local workflow_dir="${dir}/.github/workflows"
  
  if [[ ! -d "$workflow_dir" ]]; then
    error "No GitHub workflows directory found in $dir"
  fi
  
  echo "Scanning for workflow files in ${workflow_dir}..."
  
  # Find workflow files (yml or yaml)
  local workflow_files
  workflow_files=$(find "$workflow_dir" -type f \( -name "*.yml" -o -name "*.yaml" \))
  local file_count
  file_count=$(echo "$workflow_files" | wc -l)
  
  if [[ -z "$workflow_files" ]]; then
    echo "No workflow files found"
    return 0
  fi
  
  echo "Found $file_count workflow files"
  
  # Process each workflow file
  while IFS= read -r file; do
    if [[ -n "$file" ]]; then
      process_workflow_file "$file"
      echo "-------------------------------------------"
    fi
  done <<< "$workflow_files"
  
  echo "All workflow files processed"
}

# Main program - handles both standalone and GitHub CLI extension modes
main() {
  # Set default exit code
  local exit_code=0

  # Detect running mode and parse arguments
  local mode=""
  local targets=()  
  
  # Parse first argument as subcommand for both standalone and extension modes
  case "$1" in
    convert)
      mode="convert"
      shift
      ;;
    file)
      mode="file"
      shift
      ;;
    dir)
      mode="dir"
      shift
      ;;
    -h|--help)
      usage
      ;;
    -v|--version)
      echo "${CMD_NAME} v${VERSION}"
      exit 0
      ;;
    *)
      error "Unknown subcommand: $1. Run '${CMD_NAME} --help' for usage."
      ;;
  esac
  
  # Process remaining options
  while [[ $# -gt 0 ]]; do
    case "$1" in
      -n|--dry-run)
        DRY_RUN=true
        shift
        ;;
      -h|--help)
        usage
        ;;
      -v|--version)
        echo "${CMD_NAME} v${VERSION}"
        exit 0
        ;;
      -*)
        error "Unknown option: $1"
        ;;
      *)
        targets+=("$1")
        shift
        ;;
    esac
  done
  
  # Check for required tools
  if ! cmd_exists curl && ! cmd_exists gh; then
    error "Either curl or gh CLI is required"
  fi
  
  # Check for required arguments
  if [[ ${#targets[@]} -eq 0 ]]; then
    # If no targets are specified, show usage message
    error "No targets specified. Run '${CMD_NAME} --help' for usage."
  fi
  
  # Run in the appropriate mode
  case "$mode" in
    convert)
      for ref in "${targets[@]}"; do
        # Validate input to prevent command injection
        if has_dangerous_chars "$ref" || [[ "$ref" == *" "* ]]; then
          echo "Error: Invalid reference: $ref (contains potentially dangerous characters)" >&2
          exit_code=1
          continue
        fi
        
        # Check reference length
        if [[ ${#ref} -gt 150 ]]; then
          echo "Error: Reference too long: ${#ref} characters (maximum is 150)" >&2
          exit_code=1
          continue
        fi
        
        # Process valid reference
        if ! convert_reference "$ref"; then
          exit_code=1
        fi
      done
      ;;
    file)
      for file in "${targets[@]}"; do
        # Validate file path first to prevent command injection
        if has_dangerous_chars "$file" || [[ "$file" == *" "* ]]; then
          echo "Error: Invalid file path: $file (contains potentially dangerous characters)" >&2
          exit_code=1
          continue
        fi
        
        # Check path length to prevent DoS
        if [[ ${#file} -gt 255 ]]; then
          echo "Error: File path too long: ${#file} characters (maximum is 255)" >&2
          exit_code=1
          continue
        fi
        
        # Ensure file exists before processing
        if [[ ! -f "$file" ]]; then
          echo "Error: File not found: $file" >&2
          exit_code=1
          continue
        fi
        
        # Process the validated file
        process_workflow_file "$file" || {
          echo "Error processing file: $file" >&2
          exit_code=1
        }
      done
      ;;
    dir)
      for dir in "${targets[@]}"; do
        # Validate directory path first to prevent command injection
        if has_dangerous_chars "$dir" || [[ "$dir" == *" "* ]]; then
          echo "Error: Invalid directory path: $dir (contains potentially dangerous characters)" >&2
          exit_code=1
          continue
        fi
        
        # Check path length to prevent DoS
        if [[ ${#dir} -gt 255 ]]; then
          echo "Error: Directory path too long: ${#dir} characters (maximum is 255)" >&2
          exit_code=1
          continue
        fi
        
        # Ensure directory exists before processing
        if [[ ! -d "$dir" ]]; then
          echo "Error: Directory not found: $dir" >&2
          exit_code=1
          continue
        fi
        
        # Process the validated directory
        process_directory "$dir" || {
          echo "Error processing directory: $dir" >&2
          exit_code=1
        }
      done
      ;;
  esac
  
  exit $exit_code
}

# Call the main function
main "$@"
