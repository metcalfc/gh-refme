#!/bin/bash
#
# gh-refme - Convert GitHub references to commit hashes for better security
#
# This script processes GitHub Actions workflow YAML files and converts
# git references (tags, branches, short commits) to full commit hashes.
#
set -e

# Configuration and global variables
VERSION="1.5.1"
TEMP_DIR=$(mktemp -d)
DRY_RUN=false
CREATE_BACKUP=false

# Load shared library functions
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
if [[ -f "${SCRIPT_DIR}/lib/gh-refme-lib.sh" ]]; then
  source "${SCRIPT_DIR}/lib/gh-refme-lib.sh"
else
  echo "ERROR: Cannot find required library file: ${SCRIPT_DIR}/lib/gh-refme-lib.sh" >&2
  exit 1
fi

# Initialize security environment
sanitize_environment

# Detect if being run as a GitHub CLI extension
if [[ -n "$GH_CLI_VERSION" ]]; then
  CMD_NAME="gh refme"
else
  CMD_NAME="gh-refme"
fi

# Clean up temp directory on exit
trap 'rm -rf "$TEMP_DIR"' EXIT

# =============================================================================
# ASCII Art Logo
# =============================================================================
print_logo() {
  cat << 'EOF'
______        __ ___  ___      
| ___ \      / _||  \/  |      
| |_/ / ___ | |_ | .  . |  ___ 
|    / / _ \|  _|| |\/| | / _ \
| |\ \|  __/| |  | |  | ||  __/
\_| \_|\___||_|  \_|  |_/ \___|
EOF
}


# Print usage information
print_usage() {
  print_logo
  echo
  cat << EOF
${CMD_NAME} v${VERSION} - Convert GitHub references to commit hashes

USAGE:
  ${CMD_NAME} [OPTIONS] <file1.yml> [<file2.yml> ...]
  ${CMD_NAME} convert [OPTIONS] <file1.yml> [<file2.yml> ...]

DESCRIPTION:
  Processes GitHub Actions workflow files and converts git references
  (tags, branches, short commits) to full commit hashes.

OPTIONS:
  -h, --help                  Show this help message
  -n, --dry-run               Show what would be changed without making changes
  -b, --backup                Create backup files (.bak) before making changes
  -v, --version               Show version information

EXAMPLES:
  ${CMD_NAME} .github/workflows/ci.yml
  ${CMD_NAME} --dry-run .github/workflows/*.yml
  ${CMD_NAME} --backup .github/workflows/*.yml
  ${CMD_NAME} convert actions/checkout@v4
EOF
}


# =============================================================================
# File Processing Functions  
# =============================================================================

# Process a single workflow file
process_workflow_file() {
  local file="$1"
  
  # Validate file
  if ! validate_workflow_file "$file"; then
    return 0
  fi
  
  echo "Processing $file..."
  
  # Setup temporary files
  setup_temp_files "$file" "$TEMP_DIR"
  
  # Process GitHub references
  process_github_references "$TEMP_READ_FILE" "$TEMP_PROCESSING_FILE" "$file"
  
  # Apply changes
  apply_or_show_changes "$file" "$TEMP_PROCESSING_FILE" "$PROCESSED_REF_COUNT" "$PROCESSED_UPDATE_COUNT" "$DRY_RUN" "$CREATE_BACKUP"
}

# Process a directory to find workflow files
process_directory() {
  local dir="$1"
  
  if [[ ! -d "$dir" ]]; then
    error "Directory not found: $dir"
  fi
  
  # Look for GitHub workflow files
  local workflow_dir="${dir}/.github/workflows"
  
  if [[ ! -d "$workflow_dir" ]]; then
    error "No GitHub .github/workflows directory found in $dir"
  fi
  
  echo "Scanning for workflow files in ${workflow_dir}..."
  
  # Find workflow files (yml or yaml)
  local workflow_files
  workflow_files=$(find "$workflow_dir" -type f \( -name "*.yml" -o -name "*.yaml" \))
  local file_count
  file_count=$(echo "$workflow_files" | wc -l | tr -d ' ')
  
  if [[ -z "$workflow_files" || "$file_count" -eq 0 ]]; then
    echo "No workflow files found in $workflow_dir"
    return 0
  fi
  
  echo "Found $file_count workflow files"
  
  # Process each workflow file
  while IFS= read -r file; do
    if [[ -n "$file" ]]; then
      process_workflow_file "$file"
      echo "-------------------------------------------"
    fi
  done <<< "$workflow_files"
  
  echo "All workflow files processed"
}

# Convert a direct GitHub reference (for backward compatibility)
convert_reference() {
  local ref="$1"
  echo "Converting $ref..."
  
  # Check for excessively long input
  if [[ ${#ref} -gt $MAX_TOTAL_REF_LENGTH ]]; then
    echo "ERROR: Reference too long: ${#ref} characters (maximum is $MAX_TOTAL_REF_LENGTH)" >&2
    return 1
  fi
  
  # Parse reference using shared parsing function
  if ! parse_github_ref "$ref" || [[ -z "$PARSED_OWNER" ]]; then
    echo "ERROR: Invalid reference format: $ref (expected owner/repo@ref)" >&2
    return 1
  fi
  
  local owner="$PARSED_OWNER"
  local repo="$PARSED_REPO"
  local reference="$PARSED_REFERENCE"
  
  # Validate inputs using shared validation function
  validate_github_ref "$owner" "$repo" "$reference" "ERROR" || return 1
    
  # Get the hash
  local hash
  if hash=$(get_commit_hash "$owner" "$repo" "$reference" 2>/dev/null); then
    echo "âœ“ $ref -> ${owner}/${repo}@${hash} # was: $ref"
    return 0
  else
    return 1
  fi
}

# =============================================================================
# Main Function
# =============================================================================

main() {
  local files=()
  local is_convert_command=false
  
  # Check if the first argument is "convert" (for backward compatibility)
  if [[ $# -gt 0 && "$1" == "convert" ]]; then
    is_convert_command=true
    shift
  fi
  
  # Process command line options
  while [[ $# -gt 0 ]]; do
    case "$1" in
      -h|--help)
        print_usage
        exit 0
        ;;
      -n|--dry-run)
        DRY_RUN=true
        shift
        ;;
      -b|--backup)
        CREATE_BACKUP=true
        shift
        ;;
      -v|--version)
        echo "${CMD_NAME} v${VERSION}"
        exit 0
        ;;
      -*)
        error "Unknown option: $1"
        ;;
      *)
        files+=("$1")
        shift
        ;;
    esac
  done
  
  # Check for required tools
  if ! command_exists curl && ! command_exists gh; then
    error "Either curl or gh CLI is required"
  fi
  
  # Check for required arguments
  if [[ ${#files[@]} -eq 0 ]]; then
    print_usage
    exit 1
  fi
  
  # Process each file or reference
  for file in "${files[@]}"; do
    # Special handling for direct references when using 'convert' command (backward compatibility)
    if [[ "$is_convert_command" == "true" ]] && is_valid_cli_ref "$file"; then
      convert_reference "$file"
      continue
    fi
    
    # Process directories
    if [[ -d "$file" ]]; then
      process_directory "$file"
      continue
    fi
    
    # Check for path traversal attempts in file path
    if has_path_traversal "$file"; then
      echo "ERROR: Path traversal attempt detected in: $file" >&2
      continue
    fi
    
    # Handle wildcards by expanding the pattern
    if [[ "$file" == *\** ]]; then
      for matched_file in $file; do
        # Skip if the pattern didn't match any files
        if [[ ! -f "$matched_file" ]]; then
          continue
        fi
        
        process_workflow_file "$matched_file"
      done
      continue
    fi
    
    # Regular file processing
    process_workflow_file "$file"
  done
  
  echo "All files processed"
  exit 0
}

# Call the main function
main "$@"
